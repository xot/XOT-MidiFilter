# XOT-MidiFilter

Max for Live MIDI Filter effect.

(c) Jaap-Henk Hoepman (info@xot.nl)

Released under the [MIT](https://opensource.org/licenses/MIT) license. 

## Description

![Screenshot](Screenshot.png "Screenshot")


XOT-MidiFilter uses user supplied expressions to transform incoming MIDI notes, or to generate MIDI notes when triggered by an external clock. 

It can be used to shift notes, adjust note velocities, delay notes, create rhythmic patterns, process incoming chords as an arpeggiator, and much much more. The use of complex expressions allow these things to depend on the current state, on random events, and the value of three dials.

Incoming notes are stored in a chord. A node is added with a note on message, and removed with a note off message. When a node is added, its velocity is also recorded. XOT-MidiFilter can use the current chord in the expressions that generate its output by referring to `N[i]` for the i-th note, `V[i]` for the velocity of the i-th note, for i between 0 and `L`-1 (i.e. `L` denotes the number of notes in the current chord). Notes in a chord are always stored in increasing note pitch, i.e. `N[i]` is guaranteed to be smaller than `N[j]` when `i` < `j`.

XOT-MidiFilter is triggered to produce output with every clock tick. This tick is either derived from the running transport (when 'Sync' equals 1/4, 1/8 or 1/16) or triggered with each incoming note on (when 'Sync' equals 'in'). When 'Triplets' is on, the clock is synchronised on triples of the selected rate. Using 'Sync' equals 'in', the clock can be given a groove.


With every tick the following happens:

1. All expressions are read from the input.
2. The next state `NS` is computed using the state expression.
3. A loop over all notes in the current chord is started, setting an index
   `i` through values `0` to `L`-1 one by one, and performing the following steps. If the current chord is empty, the steps below are executed once, for `i` equals 0.
   
   - The gate expression is executed, and if it returns `false`, no output is produced. (Recall that `t` can be used in this expression for the current clock tick number, while `i` can be used to refer to the index of the current note in the current chord.)
   
   - Otherwise, a note is output with pitch defined by the note expression, velocity defined by the velocity expression, length defined by the length expression and delayed as defined by the delay expression.
   
4. The current tick count is incremented by 1.
5. The current state `S` is set to the next state `NS` computed earlier.



Users can define the following expressions.

Gate
: Must return a boolean. When `true`, an output is generated based on the results of the other expressions. 

Note
: Must return a note value, floating point values are rounded from below to integers. Defines the note to be output.

Velocity
: Must return a velocity value, floating point values are rounded from below to integers. Defines the velocity of the note to be output.

Length
: Length in milliseconds, floating point values are rounded from below to integers. Defines the length of the note to be output (a note off will be sent that much time later).

Delay
: Delay in milliseconds, floating point values are rounded from below to integers. Defines the delay before the note is actually output (the corresponding note off is similarly delayed).

State
: State as an integer. Defines next state ns (which becomes state s after all expressions have been evaluated for all notes in the current chord.


In the function definitions the following variables can be used.

- `t`: clock tick number, starts at 0.
- `i`: current chord note index, between 0 and `L`-1.
- `L`: current chord length.
- `N[i]`: current chord note at index `i`.
- `V[i]`: current chord note velocity at index `i`.
- `S`: the current state.
- `NS`: the new state.
- `p1`, `p2`, `p3`: the values of the three dials (between 0..100).

Moreover, the following helper functions are available.

- `e(n,k,r,i)`: the euclid generatior for n slots, k pulses, with rotation r, returning whether the slot at index i has a pulse or not (boolean). (*Note: the [algorithm used](https://paulbatchelor.github.io/sndkit/euclid/) is a simplified one-line version of the original recursive algorithm, that produces the same pattern but with a fixed but seemingly random rotation; adjust the rotation to get the actual Euclidean pattern.*) 
- `b(v)`: convert a boolean v to 0 (false) or 1 (true).
- `r()`: return a uniform random value between 0..100.
- `div(n,d)`: the integer division of n by d.

When 'Through' equals 'On', all incoming MIDI events are passed through. When 'Off', all are blocked and the output is only as generated by XOT-MidiFilter itself.

## Examples

### Repeat chord with increasing velocity

Gate
: `true`; produce output on every tick for every note in the chord.
Note
: `N[i]`; output each note in the chord.
Velocity
: `V[i]+20*(t%3)`; add 0, 20 or 40 to the velocity depending on the tick
Length
: `500`; note length is 500 ms.
Delay
: `0`; no delay.
State
: `0`; not used.

Sync could be set to 1/8.

### Arpeggiator (Up)

Gate
: `i==0`; produce output on every tick, *once* for the chord.
Note
: `N[t % L]`; output each note in the chord one by one each tick
Velocity
: `V[t % L]`; use the note velocity
Length
: `500`; note length is 500 ms.
Delay
: `0`; no delay.
State
: `0`; not used.

Sync could be set to 1/8.

### A Euclidean rhythm generator

Gate
: `e(5,3,0,t)`; 3 pulses in 5 slots; observe how `t` is used to loop over the slots in succession, opening the gate and producing output for all t for which `e(5,3,0,t)` equals true. We could also have written `e(5,3,0,t%5)`
Note
: `50`; output note 50 (i.e. D3).
Velocity
: `10+30*(t%3)`; let the velocity vary with each tick: 10, 40, 70, 10, 40, 70, etc.
Length
: `50`; note length is 50 ms.
Delay
: `r()/20`; add a random delay between 0..50 ms.
State
: `0`; not used.

Sync could be set to 1/8.

## Note

This started when I discovered that Max MSP supports LUA scripting, and I wondered whether users could enter their own scripts trough text input fields. They can, when we use the LUA `loadstring` function.
